<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Arrangement · LinearAlgebraicRepresentation.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="LinearAlgebraicRepresentation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">LinearAlgebraicRepresentation.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../lar/">L.A.R. Intro</a></li><li><a class="tocitem" href="../interface/">Interface</a></li><li class="is-active"><a class="tocitem" href>Arrangement</a><ul class="internal"><li><a class="tocitem" href="#API"><span>API</span></a></li><li><a class="tocitem" href="#Theoretical-basis"><span>Theoretical basis</span></a></li></ul></li><li><span class="tocitem">Parametric primitives</span><ul><li><a class="tocitem" href="../mapper/">Mapper</a></li><li><a class="tocitem" href="../struct/">Assemblies</a></li></ul></li><li><span class="tocitem">Grid generation</span><ul><li><a class="tocitem" href="../largrid/">Cuboidal grids</a></li><li><a class="tocitem" href="../simplexn/">Simplicial grids</a></li></ul></li><li><a class="tocitem" href="../integr/">Domain integration</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Arrangement</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Arrangement</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/master/docs/src/arrangement.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Arrangement-of-cellular-complexes"><a class="docs-heading-anchor" href="#Arrangement-of-cellular-complexes">Arrangement of cellular complexes</a><a id="Arrangement-of-cellular-complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Arrangement-of-cellular-complexes" title="Permalink"></a></h1><p>The <strong>arrangement</strong> is an algorithm which gets two general <span>$d$</span>-dimensional cellular complexes and arranges them in a singular <span>$d$</span>-dimensional cellular complex of which the cells respect the conditions:</p><ul><li><span>$\sigma_1 \cap \sigma_2 = \emptyset,\quad \forall$</span> couple of cells <span>$(\sigma_1, \sigma_2)$</span></li><li><span>$\bigcup_i\sigma_i = \mathbb{E}^d$</span></li></ul><p>This operation can be seen as a boolean union of two cellular complexes. Here an exploded visualization of the final result of the arrangement algorithm ran on 2 cubes made by <span>$10\times10\times10$</span> smaller cubes.</p><p><img src="../images/cube10x10.jpg" alt="10 x 10 Cube"/></p><blockquote><p><strong>Figure 1:</strong> Arrangement of <span>$2000=2\times10\times10\times10$</span> cubes</p></blockquote><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><p>Every function strictly relative to the arrangement has been collected in the <code>Lar.Arrangement</code> sub-module but the two main functions are accessible directly from the <code>LinearAlgebraicRepresentation</code> namespace.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>Lar.Arrangement</code> is the only place in <code>LinearAlgebraicRepresentation</code> where <code>Point</code> matrices store points per row and not per column as described in the documentation of <code>Lar.Points</code></p></div></div><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebraicRepresentation.spatial_arrangement" href="#LinearAlgebraicRepresentation.spatial_arrangement"><code>LinearAlgebraicRepresentation.spatial_arrangement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spatial_arrangement(V::Points, copEV::ChainOp, copFE::ChainOp; [multiproc::Bool])</code></pre><p>Compute the arrangement on the given cellular complex 2-skeleton in 3D.</p><p>A cellular complex is arranged when the intersection of every possible pair of cell of the complex is empty and the union of all the cells is the whole Euclidean space. The function returns the full arranged complex as a list of vertices V and a chain of borders EV, FE, CF.</p><p><strong>Additional arguments:</strong></p><ul><li><code>multiproc::Bool</code>: Runs the computation in parallel mode. Defaults to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/962282a8da36a3f36b889311c92c28379c6a2ec4/src/arrangement/spatial_arrangement.jl#L228-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebraicRepresentation.planar_arrangement" href="#LinearAlgebraicRepresentation.planar_arrangement"><code>LinearAlgebraicRepresentation.planar_arrangement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">planar_arrangement(V::Points, EV::ChainOp, [sigma::Chain], [return_edge_map::Bool], [multiproc::Bool])</code></pre><p>Compute the arrangement on the given cellular complex 1-skeleton in 2D.</p><p>A cellular complex is arranged when the intersection of every possible pair of cell of the complex is empty and the union of all the cells is the whole Euclidean space. The basic method of the function without the <code>sigma</code>, <code>return_edge_map</code> and <code>multiproc</code> arguments returns the full arranged complex <code>V</code>, <code>EV</code> and <code>FE</code>.</p><p><strong>Additional arguments:</strong></p><ul><li><code>sigma::Chain</code>: if specified, <code>planar_arrangement</code> will delete from the output every edge and face outside this cell. Defaults to an empty cell.</li><li><code>return_edge_map::Bool</code>: makes the function return also an <code>edge_map</code> which maps the edges of the imput to the one of the output. Defaults to <code>false</code>.</li><li><code>multiproc::Bool</code>: Runs the computation in parallel mode. Defaults to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/962282a8da36a3f36b889311c92c28379c6a2ec4/src/arrangement/planar_arrangement.jl#L559-L573">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Even if the arrangement algorithm is theoretically dimension independent, we implemented &quot;only&quot; the <span>$d=2$</span> and <span>$d=3$</span> version of it.</p></div></div><h2 id="Theoretical-basis"><a class="docs-heading-anchor" href="#Theoretical-basis">Theoretical basis</a><a id="Theoretical-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-basis" title="Permalink"></a></h2><p>The algorithm is based on the concept of recursive problem simplification  (a sort of <em>divide et impera</em> philosophy); if we have a <span>$d$</span>-complex, for every (<span>$d-1$</span>)-cell embedded into the <span>$\mathbb{E}^d$</span> euclidean space, we bring the cell, and every other cell that could intersect it, down into <span>$\mathbb{E}^{d-1}$</span>. We do this until we reach the <span>$d=1$</span> in <span>$\mathbb{E}^1$</span> case; in here, we fragment all the <span>$1$</span>-cells. Then, we travel back to the original <span>$d$</span>-dimension, and, for each dimensional step, we build correct complexes from cells provided by the  fragmentation of the lower dimension. </p><p><img src="../images/arrangement_steps.jpg" alt="Arrangement steps"/></p><blockquote><p><strong>Figure 2:</strong> Algorithm overview</p></blockquote><p>We have in input two cellular complexes [fig. 2, a],  given as 2-skeletons, which are the sets of 2-cells  [fig. 2, b, exploded]. Once we merged the skeletons,  we individuate for each <span>$2$</span>-cell (that we will call <span>$\sigma$</span>) all the other cells that could intersect it. We do this by computing the spatial index: it is a mapping <span>$\mathcal{I}(\sigma)$</span> from a cell  <span>$\sigma$</span> to every other cell <span>$\tau$</span> of which <span>$box(\sigma) \cap box(\tau) \neq \emptyset$</span>, where the <span>$box$</span> function provides the axis aligned bounding box (AABB) of a cell [fig. 2, c,  <span>$\sigma$</span> in red and <span>$\mathcal{I}(\sigma)$</span> in blue]. The spatial arrangement calculation is speeded up by storing the AABBs as dimensional wise intervals into an interval tree \cite{interval<em>trees}.  Now for each cell <span>$\sigma$</span> we transform <span>$\sigma \cup \mathcal{I}(\sigma)$</span>  in a way that <span>$\sigma$</span> lays on the ``x</em>3=0<span>$plane [fig. 2, d] and we find the intersections  of the$</span>\mathcal{I}(\sigma)<span>$cells with$</span>x_3=0<span>$plane. So we have a &quot;soup&quot; of 1-cells in$</span>\mathbb{E}^2<span>$[fig. 2, e], and we fragment each 1-cell  with every other cell obtaining a valid 1-skeleton [fig. 2, f]. From this data it is possible to build the 2-cells using the ALGORITHM 1 presented and explored by Paoluzzi et al. \cite{Paoluzzi} [fig. 2, g, exploded]. The procedure to fragment 1-cells on a plane and return a 2-complex is called *planar arrangement*. When the planar arrangement  is complete, fragmented$</span>\sigma<span>$can be transformed back to its original position in$</span>\mathbb{E}^3``. With every 2-cell correctly fragmented, we can use the  already cited ALGORITHM 1 again to build a full 3-complex [fig. 2, h, exploded]. This is possible because ALGORITHM 1 is (almost) dimension independent.</p><h3 id="The-&quot;1-cells-in-\\mathbb{E}2&quot;-base-case"><a class="docs-heading-anchor" href="#The-&quot;1-cells-in-\\mathbb{E}2&quot;-base-case">The &quot;<span>$1$</span>-cells in <span>$\mathbb{E}^2$</span>&quot; base case</a><a id="The-&quot;1-cells-in-\\mathbb{E}2&quot;-base-case-1"></a><a class="docs-heading-anchor-permalink" href="#The-&quot;1-cells-in-\\mathbb{E}2&quot;-base-case" title="Permalink"></a></h3><p><img src="../images/planar_arrangement.jpg" alt="Planar arrangement overview"/></p><blockquote><p><strong>Figure 3:</strong> Planar arrangement overview</p></blockquote><p>This is our base case. We have called <em>planar arrangement</em> the procedure to handle this case since it literally arranges a bunch of edges laying on a plane. So, in input there are 1-cells in <span>$\mathbb{E}^2$</span> and, optionally (but very likely), the boundary of the original 2-cell <span>$\sigma$</span>  [fig. 3, a, <span>$\sigma$</span> in red]. We consider each edge and we fragment it with every other edge. This brings to the creation of several coincident vertices: these will be eliminated using a KD-Tree [fig. 3, b, exploded].  At this point we have a perfectly fragmented 1-complex but many edges are superfluous and must be eliminated; two kind of edges are to discard: the ones outside the area of <span>$\sigma$</span> and the ones which are not part of a maximal biconnected component  (We can talk about biconnected components because we can consider the 1-skeleton as a graph:  0-cells are nodes, 1-cells are edges and the boundary operator is a incidence matrix.). The result of this edge pruning outputs a 1-skeleton [fig. 3, c, exploded].</p><p>After this, 2-cells must be computed: For each connected component we build a containment tree, which indicates which component is spatially inside an other component. Computing these relations lets us launch the ALGORITHM 1 \cite{Paoluzzi} on each component and then combine the results to create 2-cells with non-intersecting  shells [fig. 3, d, 2-cells numbered in green; please note that cell 2 has cell 1 as an hole].</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A 2-cell with a non-intersecting shell can be trivially defined as a &quot;face with holes&quot;; the correct definition is that it cannot  be shrunk to the dimension of a point.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« Interface</a><a class="docs-footer-nextpage" href="../mapper/">Mapper »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 10 March 2021 17:17">Wednesday 10 March 2021</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
